import heapq

# 8-Puzzle Problem Solver using A* Search (Manhattan Distance)

class PuzzleState:
    def __init__(self, board, parent=None, move="", depth=0, cost=0):
        self.board = board
        self.parent = parent
        self.move = move
        self.depth = depth
        self.cost = cost  # g(n) + h(n)

    def __lt__(self, other):
        return self.cost < other.cost

    def __eq__(self, other):
        return self.board == other.board

    def __hash__(self):
        return hash(tuple(self.board))

# Manhattan distance heuristic
def manhattan(board, goal):
    distance = 0
    for i, tile in enumerate(board):
        if tile != 0:
            x1, y1 = i // 3, i % 3
            x2, y2 = goal.index(tile) // 3, goal.index(tile) % 3
            distance += abs(x1 - x2) + abs(y1 - y2)
    return distance

# Generate next possible states
def get_neighbors(state, goal):
    neighbors = []
    moves = {"Up": -3, "Down": 3, "Left": -1, "Right": 1}
    zero_index = state.board.index(0)

    for move, pos in moves.items():
        new_index = zero_index + pos

        # Valid move conditions
        if move == "Left" and zero_index % 3 == 0:
            continue
        if move == "Right" and zero_index % 3 == 2:
            continue
        if new_index < 0 or new_index >= 9:
            continue

        new_board = state.board[:]
        new_board[zero_index], new_board[new_index] = new_board[new_index], new_board[zero_index]
        h = manhattan(new_board, goal)
        new_state = PuzzleState(new_board, state, move, state.depth + 1, state.depth + 1 + h)
        neighbors.append(new_state)

    return neighbors

# A* Search Algorithm
def a_star(start, goal):
    open_list = []
    closed_set = set()
    heapq.heappush(open_list, PuzzleState(start, None, "", 0, manhattan(start, goal)))

    while open_list:
        current = heapq.heappop(open_list)

        if current.board == goal:
            path = []
            while current:
                path.append(current.move)
                current = current.parent
            return path[::-1][1:]  # return moves excluding root

        closed_set.add(tuple(current.board))
        for neighbor in get_neighbors(current, goal):
            if tuple(neighbor.board) not in closed_set:
                heapq.heappush(open_list, neighbor)

    return None

# Example usage
if __name__ == "__main__":
    start = [1, 2, 3,
             4, 0, 6,
             7, 5, 8]  # Initial state (0 = blank)

    goal = [1, 2, 3,
            4, 5, 6,
            7, 8, 0]  # Goal state

    solution = a_star(start, goal)
    if solution:
        print("Solution found! Moves:", solution)
    else:
        print("No solution exists.")
